//! Hack: include from mspm0-metapac for flashctl.
//! There is better support coming upstream based on chats in matrix,
//! but for now I just need something which works on my specific part.
// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(nonstandard_style)]

#[doc = "F65NW."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Flashctl {
    ptr: *mut u8,
}
unsafe impl Send for Flashctl {}
unsafe impl Sync for Flashctl {}
impl Flashctl {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt Index Register."]
    #[inline(always)]
    pub const fn iidx(self) -> super::common::Reg<regs::Iidx, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[doc = "Interrupt Mask Register."]
    #[inline(always)]
    pub const fn imask(self) -> super::common::Reg<regs::Imask, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1028usize) as _) }
    }
    #[doc = "Raw Interrupt Status Register."]
    #[inline(always)]
    pub const fn ris(self) -> super::common::Reg<regs::Ris, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1030usize) as _) }
    }
    #[doc = "Masked Interrupt Status Register."]
    #[inline(always)]
    pub const fn mis(self) -> super::common::Reg<regs::Mis, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1038usize) as _) }
    }
    #[doc = "Interrupt Set Register."]
    #[inline(always)]
    pub const fn iset(self) -> super::common::Reg<regs::Iset, super::common::W> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1040usize) as _) }
    }
    #[doc = "Interrupt Clear Register."]
    #[inline(always)]
    pub const fn iclr(self) -> super::common::Reg<regs::Iclr, super::common::W> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1048usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> super::common::Reg<regs::EvtMode, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Hardware Version Description Register."]
    #[inline(always)]
    pub const fn desc(self) -> super::common::Reg<regs::Desc, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "Command Execute Register."]
    #[inline(always)]
    pub const fn cmdexec(self) -> super::common::Reg<regs::Cmdexec, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Command Type Register."]
    #[inline(always)]
    pub const fn cmdtype(self) -> super::common::Reg<regs::Cmdtype, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "Command Control Register."]
    #[inline(always)]
    pub const fn cmdctl(self) -> super::common::Reg<regs::Cmdctl, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "Command Address Register."]
    #[inline(always)]
    pub const fn cmdaddr(self) -> super::common::Reg<u32, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1120usize) as _) }
    }
    #[doc = "Command Program Byte Enable Register."]
    #[inline(always)]
    pub const fn cmdbyten(self) -> super::common::Reg<regs::Cmdbyten, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1124usize) as _) }
    }
    #[doc = "Command Data Register 0."]
    #[inline(always)]
    pub const fn cmddata0(self) -> super::common::Reg<u32, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1130usize) as _) }
    }
    #[doc = "Command Data Register 1."]
    #[inline(always)]
    pub const fn cmddata1(self) -> super::common::Reg<u32, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1134usize) as _) }
    }
    #[doc = "Command Data Register ECC 0."]
    #[inline(always)]
    pub const fn cmddataecc0(self) -> super::common::Reg<regs::Cmddataecc0, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x11b0usize) as _) }
    }
    #[doc = "Command Write Erase Protect A Register."]
    #[inline(always)]
    pub const fn cmdweprota(self) -> super::common::Reg<u32, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x11d0usize) as _) }
    }
    #[doc = "Command Write Erase Protect B Register."]
    #[inline(always)]
    pub const fn cmdweprotb(self) -> super::common::Reg<regs::Cmdweprotb, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x11d4usize) as _) }
    }
    #[doc = "Command Write Erase Protect Non-Main Register."]
    #[inline(always)]
    pub const fn cmdweprotnm(self) -> super::common::Reg<regs::Cmdweprotnm, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1210usize) as _) }
    }
    #[doc = "Command Write Erase Protect Trim Register."]
    #[inline(always)]
    pub const fn cmdweprottr(self) -> super::common::Reg<regs::Cmdweprottr, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1214usize) as _) }
    }
    #[doc = "Command Write Erase Protect Engr Register."]
    #[inline(always)]
    pub const fn cmdweproten(self) -> super::common::Reg<regs::Cmdweproten, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1218usize) as _) }
    }
    #[doc = "Command Configuration Register."]
    #[inline(always)]
    pub const fn cfgcmd(self) -> super::common::Reg<regs::Cfgcmd, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13b0usize) as _) }
    }
    #[doc = "Pulse Counter Configuration Register."]
    #[inline(always)]
    pub const fn cfgpcnt(self) -> super::common::Reg<regs::Cfgpcnt, super::common::RW> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13b4usize) as _) }
    }
    #[doc = "Command Status Register."]
    #[inline(always)]
    pub const fn statcmd(self) -> super::common::Reg<regs::Statcmd, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13d0usize) as _) }
    }
    #[doc = "Address Status Register."]
    #[inline(always)]
    pub const fn stataddr(self) -> super::common::Reg<regs::Stataddr, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13d4usize) as _) }
    }
    #[doc = "Pulse Count Status Register."]
    #[inline(always)]
    pub const fn statpcnt(self) -> super::common::Reg<regs::Statpcnt, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13d8usize) as _) }
    }
    #[doc = "Mode Status Register."]
    #[inline(always)]
    pub const fn statmode(self) -> super::common::Reg<regs::Statmode, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13dcusize) as _) }
    }
    #[doc = "Global Information Register 0."]
    #[inline(always)]
    pub const fn gblinfo0(self) -> super::common::Reg<regs::Gblinfo0, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13f0usize) as _) }
    }
    #[doc = "Global Information Register 1."]
    #[inline(always)]
    pub const fn gblinfo1(self) -> super::common::Reg<regs::Gblinfo1, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13f4usize) as _) }
    }
    #[doc = "Global Information Register 2."]
    #[inline(always)]
    pub const fn gblinfo2(self) -> super::common::Reg<regs::Gblinfo2, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x13f8usize) as _) }
    }
    #[doc = "Bank Information Register 0 for Bank 0."]
    #[inline(always)]
    pub const fn bank0info0(self) -> super::common::Reg<regs::Bank0info0, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1400usize) as _) }
    }
    #[doc = "Bank Information Register 1 for Bank 0."]
    #[inline(always)]
    pub const fn bank0info1(self) -> super::common::Reg<regs::Bank0info1, super::common::R> {
        unsafe { super::common::Reg::from_ptr(self.ptr.add(0x1404usize) as _) }
    }
}
pub mod regs {
    #[doc = "Bank Information Register 0 for Bank 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bank0info0(pub u32);
    impl Bank0info0 {
        #[doc = "Main region size in sectors Minimum: 0x8 (8) Maximum: 0x200 (512)."]
        #[inline(always)]
        pub const fn mainsize(&self) -> super::vals::Mainsize {
            let val = (self.0 >> 0usize) & 0x0fff;
            super::vals::Mainsize::from_bits(val as u16)
        }
        #[doc = "Main region size in sectors Minimum: 0x8 (8) Maximum: 0x200 (512)."]
        #[inline(always)]
        pub fn set_mainsize(&mut self, val: super::vals::Mainsize) {
            self.0 = (self.0 & !(0x0fff << 0usize)) | (((val.to_bits() as u32) & 0x0fff) << 0usize);
        }
    }
    impl Default for Bank0info0 {
        #[inline(always)]
        fn default() -> Bank0info0 {
            Bank0info0(0)
        }
    }
    #[doc = "Bank Information Register 1 for Bank 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bank0info1(pub u32);
    impl Bank0info1 {
        #[doc = "Non-main region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub const fn nonmainsize(&self) -> super::vals::Nonmainsize {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Nonmainsize::from_bits(val as u8)
        }
        #[doc = "Non-main region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub fn set_nonmainsize(&mut self, val: super::vals::Nonmainsize) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
        #[doc = "Trim region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub const fn trimsize(&self) -> super::vals::Trimsize {
            let val = (self.0 >> 8usize) & 0xff;
            super::vals::Trimsize::from_bits(val as u8)
        }
        #[doc = "Trim region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub fn set_trimsize(&mut self, val: super::vals::Trimsize) {
            self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
        }
        #[doc = "Engr region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub const fn engrsize(&self) -> super::vals::Engrsize {
            let val = (self.0 >> 16usize) & 0xff;
            super::vals::Engrsize::from_bits(val as u8)
        }
        #[doc = "Engr region size in sectors Minimum: 0x0 (0) Maximum: 0x10 (16)."]
        #[inline(always)]
        pub fn set_engrsize(&mut self, val: super::vals::Engrsize) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
        }
    }
    impl Default for Bank0info1 {
        #[inline(always)]
        fn default() -> Bank0info1 {
            Bank0info1(0)
        }
    }
    #[doc = "Command Configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfgcmd(pub u32);
    impl Cfgcmd {
        #[doc = "Wait State setting for program verify, erase verify and read verify."]
        #[inline(always)]
        pub const fn waitstate(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Wait State setting for program verify, erase verify and read verify."]
        #[inline(always)]
        pub fn set_waitstate(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Cfgcmd {
        #[inline(always)]
        fn default() -> Cfgcmd {
            Cfgcmd(0)
        }
    }
    #[doc = "Pulse Counter Configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfgpcnt(pub u32);
    impl Cfgpcnt {
        #[doc = "Override hard-wired maximum pulse count. If MAXERSPCNTOVR is not set, then setting this value alone will override the max pulse count for both program and erase. If MAXERSPCNTOVR is set, then this bit will only control the max pulse count setting for program. By default, this bit is 0, and a hard-wired max pulse count is used."]
        #[inline(always)]
        pub const fn maxpcntovr(&self) -> super::vals::Maxpcntovr {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Maxpcntovr::from_bits(val as u8)
        }
        #[doc = "Override hard-wired maximum pulse count. If MAXERSPCNTOVR is not set, then setting this value alone will override the max pulse count for both program and erase. If MAXERSPCNTOVR is set, then this bit will only control the max pulse count setting for program. By default, this bit is 0, and a hard-wired max pulse count is used."]
        #[inline(always)]
        pub fn set_maxpcntovr(&mut self, val: super::vals::Maxpcntovr) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Override maximum pulse counter with this value. If MAXPCNTOVR = 0, then this field is ignored. If MAXPCNTOVR = 1 and MAXERSPCNTOVR = 0, then this value will be used to override the max pulse count for both program and erase. Full max value will be {4'h0, MAXPCNTVAL} . If MAXPCNTOVR = 1 and MAXERSPCNTOVR = 1, then this value will be used to override the max pulse count for program only. Full max value will be {4'h0, MAXPCNTVAL}."]
        #[inline(always)]
        pub const fn maxpcntval(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0xff;
            val as u8
        }
        #[doc = "Override maximum pulse counter with this value. If MAXPCNTOVR = 0, then this field is ignored. If MAXPCNTOVR = 1 and MAXERSPCNTOVR = 0, then this value will be used to override the max pulse count for both program and erase. Full max value will be {4'h0, MAXPCNTVAL} . If MAXPCNTOVR = 1 and MAXERSPCNTOVR = 1, then this value will be used to override the max pulse count for program only. Full max value will be {4'h0, MAXPCNTVAL}."]
        #[inline(always)]
        pub fn set_maxpcntval(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 4usize)) | (((val as u32) & 0xff) << 4usize);
        }
    }
    impl Default for Cfgpcnt {
        #[inline(always)]
        fn default() -> Cfgpcnt {
            Cfgpcnt(0)
        }
    }
    #[doc = "Command Program Byte Enable Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdbyten(pub u32);
    impl Cmdbyten {
        #[doc = "Command Byte Enable value. A 1-bit per flash word byte value is placed in this register."]
        #[inline(always)]
        pub const fn val(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x01ff;
            val as u16
        }
        #[doc = "Command Byte Enable value. A 1-bit per flash word byte value is placed in this register."]
        #[inline(always)]
        pub fn set_val(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
        }
    }
    impl Default for Cmdbyten {
        #[inline(always)]
        fn default() -> Cmdbyten {
            Cmdbyten(0)
        }
    }
    #[doc = "Command Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdctl(pub u32);
    impl Cmdctl {
        #[doc = "Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."]
        #[inline(always)]
        pub const fn modesel(&self) -> super::vals::Modesel {
            let val = (self.0 >> 0usize) & 0x0f;
            super::vals::Modesel::from_bits(val as u8)
        }
        #[doc = "Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."]
        #[inline(always)]
        pub fn set_modesel(&mut self, val: super::vals::Modesel) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
        }
        #[doc = "Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."]
        #[inline(always)]
        pub const fn regionsel(&self) -> super::vals::Regionsel {
            let val = (self.0 >> 9usize) & 0x0f;
            super::vals::Regionsel::from_bits(val as u8)
        }
        #[doc = "Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."]
        #[inline(always)]
        pub fn set_regionsel(&mut self, val: super::vals::Regionsel) {
            self.0 = (self.0 & !(0x0f << 9usize)) | (((val.to_bits() as u32) & 0x0f) << 9usize);
        }
        #[doc = "Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."]
        #[inline(always)]
        pub const fn addrxlateovr(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."]
        #[inline(always)]
        pub fn set_addrxlateovr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Override hardware generation of ECC data for program. Use data written to CMDDATAECC*."]
        #[inline(always)]
        pub const fn eccgenovr(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Override hardware generation of ECC data for program. Use data written to CMDDATAECC*."]
        #[inline(always)]
        pub fn set_eccgenovr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."]
        #[inline(always)]
        pub const fn sserasedis(&self) -> super::vals::Sserasedis {
            let val = (self.0 >> 20usize) & 0x01;
            super::vals::Sserasedis::from_bits(val as u8)
        }
        #[doc = "Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."]
        #[inline(always)]
        pub fn set_sserasedis(&mut self, val: super::vals::Sserasedis) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
        }
        #[doc = "Enable invalid data verify. This checks for 0->1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."]
        #[inline(always)]
        pub const fn dataveren(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "Enable invalid data verify. This checks for 0->1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."]
        #[inline(always)]
        pub fn set_dataveren(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
    }
    impl Default for Cmdctl {
        #[inline(always)]
        fn default() -> Cmdctl {
            Cmdctl(0)
        }
    }
    #[doc = "Command Data Register ECC 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmddataecc0(pub u32);
    impl Cmddataecc0 {
        #[doc = "ECC data for bits 63:0 of the data is placed here."]
        #[inline(always)]
        pub const fn val0(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "ECC data for bits 63:0 of the data is placed here."]
        #[inline(always)]
        pub fn set_val0(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Cmddataecc0 {
        #[inline(always)]
        fn default() -> Cmddataecc0 {
            Cmddataecc0(0)
        }
    }
    #[doc = "Command Execute Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdexec(pub u32);
    impl Cmdexec {
        #[doc = "Command Execute value Initiates execution of the command specified in the CMDTYPE register."]
        #[inline(always)]
        pub const fn val(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Command Execute value Initiates execution of the command specified in the CMDTYPE register."]
        #[inline(always)]
        pub fn set_val(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Cmdexec {
        #[inline(always)]
        fn default() -> Cmdexec {
            Cmdexec(0)
        }
    }
    #[doc = "Command Type Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdtype(pub u32);
    impl Cmdtype {
        #[doc = "Command type."]
        #[inline(always)]
        pub const fn command(&self) -> super::vals::Command {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Command::from_bits(val as u8)
        }
        #[doc = "Command type."]
        #[inline(always)]
        pub fn set_command(&mut self, val: super::vals::Command) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Command size."]
        #[inline(always)]
        pub const fn size(&self) -> super::vals::Size {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Size::from_bits(val as u8)
        }
        #[doc = "Command size."]
        #[inline(always)]
        pub fn set_size(&mut self, val: super::vals::Size) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
    }
    impl Default for Cmdtype {
        #[inline(always)]
        fn default() -> Cmdtype {
            Cmdtype(0)
        }
    }
    #[doc = "Command Write Erase Protect B Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdweprotb(pub u32);
    impl Cmdweprotb {
        #[doc = "Each bit protects a group of 8 sectors. When a bit is 1, the associated 8 sectors in the flash will be protected from program and erase. A maximum of 256 sectors can be protected with this register."]
        #[inline(always)]
        pub const fn val(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x0fff;
            val as u16
        }
        #[doc = "Each bit protects a group of 8 sectors. When a bit is 1, the associated 8 sectors in the flash will be protected from program and erase. A maximum of 256 sectors can be protected with this register."]
        #[inline(always)]
        pub fn set_val(&mut self, val: u16) {
            self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
        }
    }
    impl Default for Cmdweprotb {
        #[inline(always)]
        fn default() -> Cmdweprotb {
            Cmdweprotb(0)
        }
    }
    #[doc = "Command Write Erase Protect Engr Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdweproten(pub u32);
    impl Cmdweproten {
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the engr region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the engr region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the engr region will be protected from program and erase."]
        #[inline(always)]
        pub const fn val(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x03;
            val as u8
        }
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the engr region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the engr region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the engr region will be protected from program and erase."]
        #[inline(always)]
        pub fn set_val(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Cmdweproten {
        #[inline(always)]
        fn default() -> Cmdweproten {
            Cmdweproten(0)
        }
    }
    #[doc = "Command Write Erase Protect Non-Main Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdweprotnm(pub u32);
    impl Cmdweprotnm {
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the non-main region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the non-main region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the non-main will be protected from program and erase."]
        #[inline(always)]
        pub const fn val(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the non-main region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the non-main region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the non-main will be protected from program and erase."]
        #[inline(always)]
        pub fn set_val(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Cmdweprotnm {
        #[inline(always)]
        fn default() -> Cmdweprotnm {
            Cmdweprotnm(0)
        }
    }
    #[doc = "Command Write Erase Protect Trim Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cmdweprottr(pub u32);
    impl Cmdweprottr {
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the engr region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the engr region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the engr region will be protected from program and erase."]
        #[inline(always)]
        pub const fn val(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Each bit protects 1 sector. bit \\[0\\]: When 1, sector 0 of the engr region will be protected from program. and erase. bit \\[1\\]: When 1, sector 1 of the engr region will be protected from program and erase. : : bit \\[31\\]: When 1, sector 31 of the engr region will be protected from program and erase."]
        #[inline(always)]
        pub fn set_val(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Cmdweprottr {
        #[inline(always)]
        fn default() -> Cmdweprottr {
            Cmdweprottr(0)
        }
    }
    #[doc = "Hardware Version Description Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor Revision."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor Revision."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major Revision."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major Revision."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Instance number."]
        #[inline(always)]
        pub const fn instnum(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Instance number."]
        #[inline(always)]
        pub fn set_instnum(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "Feature set."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature set."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module ID."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module ID."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for peripheral event."]
        #[inline(always)]
        pub const fn int0_cfg(&self) -> super::vals::Int0Cfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Int0Cfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for peripheral event."]
        #[inline(always)]
        pub fn set_int0_cfg(&mut self, val: super::vals::Int0Cfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "Global Information Register 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gblinfo0(pub u32);
    impl Gblinfo0 {
        #[doc = "Sector size in bytes."]
        #[inline(always)]
        pub const fn sectorsize(&self) -> super::vals::Sectorsize {
            let val = (self.0 >> 0usize) & 0xffff;
            super::vals::Sectorsize::from_bits(val as u16)
        }
        #[doc = "Sector size in bytes."]
        #[inline(always)]
        pub fn set_sectorsize(&mut self, val: super::vals::Sectorsize) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
        }
        #[doc = "Number of banks instantiated Minimum: 1 Maximum: 5."]
        #[inline(always)]
        pub const fn numbanks(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x07;
            val as u8
        }
        #[doc = "Number of banks instantiated Minimum: 1 Maximum: 5."]
        #[inline(always)]
        pub fn set_numbanks(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
        }
    }
    impl Default for Gblinfo0 {
        #[inline(always)]
        fn default() -> Gblinfo0 {
            Gblinfo0(0)
        }
    }
    #[doc = "Global Information Register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gblinfo1(pub u32);
    impl Gblinfo1 {
        #[doc = "Data width in bits."]
        #[inline(always)]
        pub const fn datawidth(&self) -> super::vals::Datawidth {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Datawidth::from_bits(val as u8)
        }
        #[doc = "Data width in bits."]
        #[inline(always)]
        pub fn set_datawidth(&mut self, val: super::vals::Datawidth) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
        #[doc = "ECC data width in bits."]
        #[inline(always)]
        pub const fn eccwidth(&self) -> super::vals::Eccwidth {
            let val = (self.0 >> 8usize) & 0x1f;
            super::vals::Eccwidth::from_bits(val as u8)
        }
        #[doc = "ECC data width in bits."]
        #[inline(always)]
        pub fn set_eccwidth(&mut self, val: super::vals::Eccwidth) {
            self.0 = (self.0 & !(0x1f << 8usize)) | (((val.to_bits() as u32) & 0x1f) << 8usize);
        }
        #[doc = "Redundant data width in bits."]
        #[inline(always)]
        pub const fn redwidth(&self) -> super::vals::Redwidth {
            let val = (self.0 >> 16usize) & 0x07;
            super::vals::Redwidth::from_bits(val as u8)
        }
        #[doc = "Redundant data width in bits."]
        #[inline(always)]
        pub fn set_redwidth(&mut self, val: super::vals::Redwidth) {
            self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
        }
    }
    impl Default for Gblinfo1 {
        #[inline(always)]
        fn default() -> Gblinfo1 {
            Gblinfo1(0)
        }
    }
    #[doc = "Global Information Register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gblinfo2(pub u32);
    impl Gblinfo2 {
        #[doc = "Number of data registers present."]
        #[inline(always)]
        pub const fn dataregisters(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Number of data registers present."]
        #[inline(always)]
        pub fn set_dataregisters(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Gblinfo2 {
        #[inline(always)]
        fn default() -> Gblinfo2 {
            Gblinfo2(0)
        }
    }
    #[doc = "Interrupt Clear Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iclr(pub u32);
    impl Iclr {
        #[doc = "0: No effect 1: Clear the DONE interrupt in the RIS register."]
        #[inline(always)]
        pub const fn done(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "0: No effect 1: Clear the DONE interrupt in the RIS register."]
        #[inline(always)]
        pub fn set_done(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Iclr {
        #[inline(always)]
        fn default() -> Iclr {
            Iclr(0)
        }
    }
    #[doc = "Interrupt Index Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Indicates which interrupt has fired. 0x0 means no event pending. The priority order is fixed. On each read, only one interrupt is indicated. On a read, the current interrupt (highest priority) is automatically cleared by the hardware and the corresponding interrupt flags in the RIS and MIS are cleared as well. After a read from the CPU (not from the debug interface), the register must be updated with the next highest priority interrupt."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Stat {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Stat::from_bits(val as u8)
        }
        #[doc = "Indicates which interrupt has fired. 0x0 means no event pending. The priority order is fixed. On each read, only one interrupt is indicated. On a read, the current interrupt (highest priority) is automatically cleared by the hardware and the corresponding interrupt flags in the RIS and MIS are cleared as well. After a read from the CPU (not from the debug interface), the register must be updated with the next highest priority interrupt."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Stat) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Interrupt Mask Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Imask(pub u32);
    impl Imask {
        #[doc = "Interrupt mask for DONE: 0: Interrupt is disabled in MIS register 1: Interrupt is enabled in MIS register."]
        #[inline(always)]
        pub const fn done(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Interrupt mask for DONE: 0: Interrupt is disabled in MIS register 1: Interrupt is enabled in MIS register."]
        #[inline(always)]
        pub fn set_done(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Imask {
        #[inline(always)]
        fn default() -> Imask {
            Imask(0)
        }
    }
    #[doc = "Interrupt Set Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iset(pub u32);
    impl Iset {
        #[doc = "0: No effect 1: Set the DONE interrupt in the RIS register."]
        #[inline(always)]
        pub const fn done(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "0: No effect 1: Set the DONE interrupt in the RIS register."]
        #[inline(always)]
        pub fn set_done(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Iset {
        #[inline(always)]
        fn default() -> Iset {
            Iset(0)
        }
    }
    #[doc = "Masked Interrupt Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mis(pub u32);
    impl Mis {
        #[doc = "Flash wrapper operation completed. This masked interrupt bit reflects the bitwise AND of the corresponding RIS and IMASK bits."]
        #[inline(always)]
        pub const fn done(&self) -> super::vals::MisDone {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::MisDone::from_bits(val as u8)
        }
        #[doc = "Flash wrapper operation completed. This masked interrupt bit reflects the bitwise AND of the corresponding RIS and IMASK bits."]
        #[inline(always)]
        pub fn set_done(&mut self, val: super::vals::MisDone) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Mis {
        #[inline(always)]
        fn default() -> Mis {
            Mis(0)
        }
    }
    #[doc = "Raw Interrupt Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ris(pub u32);
    impl Ris {
        #[doc = "Flash wrapper operation completed. This interrupt bit is set by firmware or the corresponding bit in the ISET register. It is cleared by the corresponding bit in in the ICLR register or reading the IIDX register when this interrupt is the highest priority."]
        #[inline(always)]
        pub const fn done(&self) -> super::vals::RisDone {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::RisDone::from_bits(val as u8)
        }
        #[doc = "Flash wrapper operation completed. This interrupt bit is set by firmware or the corresponding bit in the ISET register. It is cleared by the corresponding bit in in the ICLR register or reading the IIDX register when this interrupt is the highest priority."]
        #[inline(always)]
        pub fn set_done(&mut self, val: super::vals::RisDone) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Ris {
        #[inline(always)]
        fn default() -> Ris {
            Ris(0)
        }
    }
    #[doc = "Address Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stataddr(pub u32);
    impl Stataddr {
        #[doc = "Current Bank Address A bank offset address is stored in this register."]
        #[inline(always)]
        pub const fn bankaddr(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "Current Bank Address A bank offset address is stored in this register."]
        #[inline(always)]
        pub fn set_bankaddr(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
        #[doc = "Current Region ID A region indicator is stored in this register which represents the current flash region on which the state machine is operating."]
        #[inline(always)]
        pub const fn regionid(&self) -> super::vals::Regionid {
            let val = (self.0 >> 16usize) & 0x1f;
            super::vals::Regionid::from_bits(val as u8)
        }
        #[doc = "Current Region ID A region indicator is stored in this register which represents the current flash region on which the state machine is operating."]
        #[inline(always)]
        pub fn set_regionid(&mut self, val: super::vals::Regionid) {
            self.0 = (self.0 & !(0x1f << 16usize)) | (((val.to_bits() as u32) & 0x1f) << 16usize);
        }
        #[doc = "Current Bank ID A bank indicator is stored in this register which represents the current bank on which the state machine is operating. There is 1 bit per bank."]
        #[inline(always)]
        pub const fn bankid(&self) -> super::vals::Bankid {
            let val = (self.0 >> 21usize) & 0x1f;
            super::vals::Bankid::from_bits(val as u8)
        }
        #[doc = "Current Bank ID A bank indicator is stored in this register which represents the current bank on which the state machine is operating. There is 1 bit per bank."]
        #[inline(always)]
        pub fn set_bankid(&mut self, val: super::vals::Bankid) {
            self.0 = (self.0 & !(0x1f << 21usize)) | (((val.to_bits() as u32) & 0x1f) << 21usize);
        }
    }
    impl Default for Stataddr {
        #[inline(always)]
        fn default() -> Stataddr {
            Stataddr(0)
        }
    }
    #[doc = "Command Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Statcmd(pub u32);
    impl Statcmd {
        #[doc = "Command Done."]
        #[inline(always)]
        pub const fn cmddone(&self) -> super::vals::Cmddone {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Cmddone::from_bits(val as u8)
        }
        #[doc = "Command Done."]
        #[inline(always)]
        pub fn set_cmddone(&mut self, val: super::vals::Cmddone) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Command Pass - valid when CMD_DONE field is 1."]
        #[inline(always)]
        pub const fn cmdpass(&self) -> super::vals::Cmdpass {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Cmdpass::from_bits(val as u8)
        }
        #[doc = "Command Pass - valid when CMD_DONE field is 1."]
        #[inline(always)]
        pub fn set_cmdpass(&mut self, val: super::vals::Cmdpass) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Command In Progress."]
        #[inline(always)]
        pub const fn cmdinprogress(&self) -> super::vals::Cmdinprogress {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Cmdinprogress::from_bits(val as u8)
        }
        #[doc = "Command In Progress."]
        #[inline(always)]
        pub fn set_cmdinprogress(&mut self, val: super::vals::Cmdinprogress) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "Command failed due to Write/Erase Protect Sector Violation."]
        #[inline(always)]
        pub const fn failweprot(&self) -> super::vals::Failweprot {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Failweprot::from_bits(val as u8)
        }
        #[doc = "Command failed due to Write/Erase Protect Sector Violation."]
        #[inline(always)]
        pub fn set_failweprot(&mut self, val: super::vals::Failweprot) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Command failed due to verify error."]
        #[inline(always)]
        pub const fn failverify(&self) -> super::vals::Failverify {
            let val = (self.0 >> 5usize) & 0x01;
            super::vals::Failverify::from_bits(val as u8)
        }
        #[doc = "Command failed due to verify error."]
        #[inline(always)]
        pub fn set_failverify(&mut self, val: super::vals::Failverify) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
        }
        #[doc = "Command failed due to the use of an illegal address."]
        #[inline(always)]
        pub const fn faililladdr(&self) -> super::vals::Faililladdr {
            let val = (self.0 >> 6usize) & 0x01;
            super::vals::Faililladdr::from_bits(val as u8)
        }
        #[doc = "Command failed due to the use of an illegal address."]
        #[inline(always)]
        pub fn set_faililladdr(&mut self, val: super::vals::Faililladdr) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
        }
        #[doc = "Command failed because a bank has been set to a mode other than READ. Program and Erase commands cannot be initiated unless all banks are in READ mode."]
        #[inline(always)]
        pub const fn failmode(&self) -> super::vals::Failmode {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Failmode::from_bits(val as u8)
        }
        #[doc = "Command failed because a bank has been set to a mode other than READ. Program and Erase commands cannot be initiated unless all banks are in READ mode."]
        #[inline(always)]
        pub fn set_failmode(&mut self, val: super::vals::Failmode) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
        #[doc = "Program command failed because an attempt was made to program a stored 0 value to a 1."]
        #[inline(always)]
        pub const fn failinvdata(&self) -> super::vals::Failinvdata {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Failinvdata::from_bits(val as u8)
        }
        #[doc = "Program command failed because an attempt was made to program a stored 0 value to a 1."]
        #[inline(always)]
        pub fn set_failinvdata(&mut self, val: super::vals::Failinvdata) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Command failed due to error other than write/erase protect violation or verify error. This is an extra bit in case a new failure mechanism is added which requires a status bit."]
        #[inline(always)]
        pub const fn failmisc(&self) -> super::vals::Failmisc {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Failmisc::from_bits(val as u8)
        }
        #[doc = "Command failed due to error other than write/erase protect violation or verify error. This is an extra bit in case a new failure mechanism is added which requires a status bit."]
        #[inline(always)]
        pub fn set_failmisc(&mut self, val: super::vals::Failmisc) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Statcmd {
        #[inline(always)]
        fn default() -> Statcmd {
            Statcmd(0)
        }
    }
    #[doc = "Mode Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Statmode(pub u32);
    impl Statmode {
        #[doc = "Bank not in read mode. Indicates which banks are not in READ mode. There is 1 bit per bank."]
        #[inline(always)]
        pub const fn banknotinrd(&self) -> super::vals::Banknotinrd {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Banknotinrd::from_bits(val as u8)
        }
        #[doc = "Bank not in read mode. Indicates which banks are not in READ mode. There is 1 bit per bank."]
        #[inline(always)]
        pub fn set_banknotinrd(&mut self, val: super::vals::Banknotinrd) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Indicates mode of bank(s) that are not in READ mode."]
        #[inline(always)]
        pub const fn bankmode(&self) -> super::vals::Bankmode {
            let val = (self.0 >> 8usize) & 0x0f;
            super::vals::Bankmode::from_bits(val as u8)
        }
        #[doc = "Indicates mode of bank(s) that are not in READ mode."]
        #[inline(always)]
        pub fn set_bankmode(&mut self, val: super::vals::Bankmode) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u32) & 0x0f) << 8usize);
        }
        #[doc = "Bank 2T Ready. Bank(s) are ready for 2T access. This is accomplished when the pump has fully driven power rails to the bank(s)."]
        #[inline(always)]
        pub const fn bank2trdy(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Bank 2T Ready. Bank(s) are ready for 2T access. This is accomplished when the pump has fully driven power rails to the bank(s)."]
        #[inline(always)]
        pub fn set_bank2trdy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Bank 1T Ready. Bank(s) are ready for 1T access. This is accomplished when the bank and pump have been trimmed."]
        #[inline(always)]
        pub const fn bank1trdy(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Bank 1T Ready. Bank(s) are ready for 1T access. This is accomplished when the bank and pump have been trimmed."]
        #[inline(always)]
        pub fn set_bank1trdy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Statmode {
        #[inline(always)]
        fn default() -> Statmode {
            Statmode(0)
        }
    }
    #[doc = "Pulse Count Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Statpcnt(pub u32);
    impl Statpcnt {
        #[doc = "Current Pulse Counter Value."]
        #[inline(always)]
        pub const fn pulsecnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x0fff;
            val as u16
        }
        #[doc = "Current Pulse Counter Value."]
        #[inline(always)]
        pub fn set_pulsecnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
        }
    }
    impl Default for Statpcnt {
        #[inline(always)]
        fn default() -> Statpcnt {
            Statpcnt(0)
        }
    }
}
pub mod vals {
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Bankid(pub u8);
    impl Bankid {
        #[doc = "Bank 0."]
        pub const BANK0: Self = Self(0x01);
        #[doc = "Bank 1."]
        pub const BANK1: Self = Self(0x02);
        #[doc = "Bank 2."]
        pub const BANK2: Self = Self(0x04);
        #[doc = "Bank 3."]
        pub const BANK3: Self = Self(0x08);
        #[doc = "Bank 4."]
        pub const BANK4: Self = Self(0x10);
    }
    impl Bankid {
        pub const fn from_bits(val: u8) -> Bankid {
            Self(val & 0x1f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Bankid {
        #[inline(always)]
        fn from(val: u8) -> Bankid {
            Bankid::from_bits(val)
        }
    }
    impl From<Bankid> for u8 {
        #[inline(always)]
        fn from(val: Bankid) -> u8 {
            Bankid::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Bankmode {
        #[doc = "Read Mode."]
        READ = 0x0,
        _RESERVED_1 = 0x01,
        #[doc = "Read Margin 0 Mode."]
        RDMARG0 = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Read Margin 1 Mode."]
        RDMARG1 = 0x04,
        _RESERVED_5 = 0x05,
        #[doc = "Read Margin 0B Mode."]
        RDMARG0B = 0x06,
        #[doc = "Read Margin 1B Mode."]
        RDMARG1B = 0x07,
        _RESERVED_8 = 0x08,
        #[doc = "Program Verify Mode."]
        PGMVER = 0x09,
        #[doc = "Program Single Word."]
        PGMSW = 0x0a,
        #[doc = "Erase Verify Mode."]
        ERASEVER = 0x0b,
        #[doc = "Erase Sector."]
        ERASESECT = 0x0c,
        _RESERVED_d = 0x0d,
        #[doc = "Program Multiple Word."]
        PGMMW = 0x0e,
        #[doc = "Erase Bank."]
        ERASEBNK = 0x0f,
    }
    impl Bankmode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Bankmode {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Bankmode {
        #[inline(always)]
        fn from(val: u8) -> Bankmode {
            Bankmode::from_bits(val)
        }
    }
    impl From<Bankmode> for u8 {
        #[inline(always)]
        fn from(val: Bankmode) -> u8 {
            Bankmode::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Banknotinrd {
        _RESERVED_0 = 0x0,
        #[doc = "Bank 0."]
        BANK0 = 0x01,
    }
    impl Banknotinrd {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Banknotinrd {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Banknotinrd {
        #[inline(always)]
        fn from(val: u8) -> Banknotinrd {
            Banknotinrd::from_bits(val)
        }
    }
    impl From<Banknotinrd> for u8 {
        #[inline(always)]
        fn from(val: Banknotinrd) -> u8 {
            Banknotinrd::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Cmddone {
        #[doc = "Not Done."]
        STATNOTDONE = 0x0,
        #[doc = "Done."]
        STATDONE = 0x01,
    }
    impl Cmddone {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cmddone {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cmddone {
        #[inline(always)]
        fn from(val: u8) -> Cmddone {
            Cmddone::from_bits(val)
        }
    }
    impl From<Cmddone> for u8 {
        #[inline(always)]
        fn from(val: Cmddone) -> u8 {
            Cmddone::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Cmdinprogress {
        #[doc = "Complete."]
        STATCOMPLETE = 0x0,
        #[doc = "In Progress."]
        STATINPROGRESS = 0x01,
    }
    impl Cmdinprogress {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cmdinprogress {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cmdinprogress {
        #[inline(always)]
        fn from(val: u8) -> Cmdinprogress {
            Cmdinprogress::from_bits(val)
        }
    }
    impl From<Cmdinprogress> for u8 {
        #[inline(always)]
        fn from(val: Cmdinprogress) -> u8 {
            Cmdinprogress::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Cmdpass {
        #[doc = "Fail."]
        STATFAIL = 0x0,
        #[doc = "Pass."]
        STATPASS = 0x01,
    }
    impl Cmdpass {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cmdpass {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cmdpass {
        #[inline(always)]
        fn from(val: u8) -> Cmdpass {
            Cmdpass::from_bits(val)
        }
    }
    impl From<Cmdpass> for u8 {
        #[inline(always)]
        fn from(val: Cmdpass) -> u8 {
            Cmdpass::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Command {
        #[doc = "No Operation."]
        NOOP = 0x0,
        #[doc = "Program."]
        PROGRAM = 0x01,
        #[doc = "Erase."]
        ERASE = 0x02,
        #[doc = "Read Verify - Perform a standalone read verify operation."]
        READVERIFY = 0x03,
        #[doc = "Mode Change - Perform a mode change only, no other operation."]
        MODECHANGE = 0x04,
        #[doc = "Clear Status - Clear status bits in FW_SMSTAT only."]
        CLEARSTATUS = 0x05,
        #[doc = "Blank Verify - Check whether a flash word is in the erased state. This command may only be used with CMDTYPE.SIZE = ONEWORD."]
        BLANKVERIFY = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Command {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Command {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Command {
        #[inline(always)]
        fn from(val: u8) -> Command {
            Command::from_bits(val)
        }
    }
    impl From<Command> for u8 {
        #[inline(always)]
        fn from(val: Command) -> u8 {
            Command::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Datawidth(pub u8);
    impl Datawidth {
        #[doc = "Data width is 64 bits."]
        pub const W64BIT: Self = Self(0x40);
        #[doc = "Data width is 128 bits."]
        pub const W128BIT: Self = Self(0x80);
    }
    impl Datawidth {
        pub const fn from_bits(val: u8) -> Datawidth {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Datawidth {
        #[inline(always)]
        fn from(val: u8) -> Datawidth {
            Datawidth::from_bits(val)
        }
    }
    impl From<Datawidth> for u8 {
        #[inline(always)]
        fn from(val: Datawidth) -> u8 {
            Datawidth::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Eccwidth(pub u8);
    impl Eccwidth {
        #[doc = "ECC data width is 0. ECC not used."]
        pub const W0BIT: Self = Self(0x0);
        #[doc = "ECC data width is 8 bits."]
        pub const W8BIT: Self = Self(0x08);
        #[doc = "ECC data width is 16 bits."]
        pub const W16BIT: Self = Self(0x10);
    }
    impl Eccwidth {
        pub const fn from_bits(val: u8) -> Eccwidth {
            Self(val & 0x1f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Eccwidth {
        #[inline(always)]
        fn from(val: u8) -> Eccwidth {
            Eccwidth::from_bits(val)
        }
    }
    impl From<Eccwidth> for u8 {
        #[inline(always)]
        fn from(val: Eccwidth) -> u8 {
            Eccwidth::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Engrsize(pub u8);
    impl Engrsize {
        #[doc = "Minimum value of \\[ENGRSIZE\\]."]
        pub const MINSECTORS: Self = Self(0x0);
        #[doc = "Maximum value of \\[ENGRSIZE\\]."]
        pub const MAXSECTORS: Self = Self(0x20);
    }
    impl Engrsize {
        pub const fn from_bits(val: u8) -> Engrsize {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Engrsize {
        #[inline(always)]
        fn from(val: u8) -> Engrsize {
            Engrsize::from_bits(val)
        }
    }
    impl From<Engrsize> for u8 {
        #[inline(always)]
        fn from(val: Engrsize) -> u8 {
            Engrsize::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Faililladdr {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Faililladdr {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Faililladdr {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Faililladdr {
        #[inline(always)]
        fn from(val: u8) -> Faililladdr {
            Faililladdr::from_bits(val)
        }
    }
    impl From<Faililladdr> for u8 {
        #[inline(always)]
        fn from(val: Faililladdr) -> u8 {
            Faililladdr::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Failinvdata {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Failinvdata {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Failinvdata {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Failinvdata {
        #[inline(always)]
        fn from(val: u8) -> Failinvdata {
            Failinvdata::from_bits(val)
        }
    }
    impl From<Failinvdata> for u8 {
        #[inline(always)]
        fn from(val: Failinvdata) -> u8 {
            Failinvdata::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Failmisc {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Failmisc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Failmisc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Failmisc {
        #[inline(always)]
        fn from(val: u8) -> Failmisc {
            Failmisc::from_bits(val)
        }
    }
    impl From<Failmisc> for u8 {
        #[inline(always)]
        fn from(val: Failmisc) -> u8 {
            Failmisc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Failmode {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Failmode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Failmode {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Failmode {
        #[inline(always)]
        fn from(val: u8) -> Failmode {
            Failmode::from_bits(val)
        }
    }
    impl From<Failmode> for u8 {
        #[inline(always)]
        fn from(val: Failmode) -> u8 {
            Failmode::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Failverify {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Failverify {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Failverify {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Failverify {
        #[inline(always)]
        fn from(val: u8) -> Failverify {
            Failverify::from_bits(val)
        }
    }
    impl From<Failverify> for u8 {
        #[inline(always)]
        fn from(val: Failverify) -> u8 {
            Failverify::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Failweprot {
        #[doc = "No Fail."]
        STATNOFAIL = 0x0,
        #[doc = "Fail."]
        STATFAIL = 0x01,
    }
    impl Failweprot {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Failweprot {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Failweprot {
        #[inline(always)]
        fn from(val: u8) -> Failweprot {
            Failweprot::from_bits(val)
        }
    }
    impl From<Failweprot> for u8 {
        #[inline(always)]
        fn from(val: Failweprot) -> u8 {
            Failweprot::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Int0Cfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. Hardware should clear the RIS."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Int0Cfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Int0Cfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Int0Cfg {
        #[inline(always)]
        fn from(val: u8) -> Int0Cfg {
            Int0Cfg::from_bits(val)
        }
    }
    impl From<Int0Cfg> for u8 {
        #[inline(always)]
        fn from(val: Int0Cfg) -> u8 {
            Int0Cfg::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Mainsize(pub u16);
    impl Mainsize {
        #[doc = "Minimum value of \\[MAINSIZE\\]."]
        pub const MINSECTORS: Self = Self(0x08);
        #[doc = "Maximum value of \\[MAINSIZE\\]."]
        pub const MAXSECTORS: Self = Self(0x0200);
    }
    impl Mainsize {
        pub const fn from_bits(val: u16) -> Mainsize {
            Self(val & 0x0fff)
        }
        pub const fn to_bits(self) -> u16 {
            self.0
        }
    }
    impl From<u16> for Mainsize {
        #[inline(always)]
        fn from(val: u16) -> Mainsize {
            Mainsize::from_bits(val)
        }
    }
    impl From<Mainsize> for u16 {
        #[inline(always)]
        fn from(val: Mainsize) -> u16 {
            Mainsize::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Maxpcntovr {
        #[doc = "Use hard-wired (default) value for maximum pulse count."]
        DEFAULT = 0x0,
        #[doc = "Use value from MAXPCNTVAL field as maximum puse count."]
        OVERRIDE = 0x01,
    }
    impl Maxpcntovr {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Maxpcntovr {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Maxpcntovr {
        #[inline(always)]
        fn from(val: u8) -> Maxpcntovr {
            Maxpcntovr::from_bits(val)
        }
    }
    impl From<Maxpcntovr> for u8 {
        #[inline(always)]
        fn from(val: Maxpcntovr) -> u8 {
            Maxpcntovr::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum MisDone {
        #[doc = "Masked interrupt did not occur."]
        CLR = 0x0,
        #[doc = "Masked interrupt occurred."]
        SET = 0x01,
    }
    impl MisDone {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> MisDone {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for MisDone {
        #[inline(always)]
        fn from(val: u8) -> MisDone {
            MisDone::from_bits(val)
        }
    }
    impl From<MisDone> for u8 {
        #[inline(always)]
        fn from(val: MisDone) -> u8 {
            MisDone::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Modesel {
        #[doc = "Read Mode."]
        READ = 0x0,
        _RESERVED_1 = 0x01,
        #[doc = "Read Margin 0 Mode."]
        RDMARG0 = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Read Margin 1 Mode."]
        RDMARG1 = 0x04,
        _RESERVED_5 = 0x05,
        #[doc = "Read Margin 0B Mode."]
        RDMARG0B = 0x06,
        #[doc = "Read Margin 1B Mode."]
        RDMARG1B = 0x07,
        _RESERVED_8 = 0x08,
        #[doc = "Program Verify Mode."]
        PGMVER = 0x09,
        #[doc = "Program Single Word."]
        PGMSW = 0x0a,
        #[doc = "Erase Verify Mode."]
        ERASEVER = 0x0b,
        #[doc = "Erase Sector."]
        ERASESECT = 0x0c,
        _RESERVED_d = 0x0d,
        #[doc = "Program Multiple Word."]
        PGMMW = 0x0e,
        #[doc = "Erase Bank."]
        ERASEBNK = 0x0f,
    }
    impl Modesel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Modesel {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Modesel {
        #[inline(always)]
        fn from(val: u8) -> Modesel {
            Modesel::from_bits(val)
        }
    }
    impl From<Modesel> for u8 {
        #[inline(always)]
        fn from(val: Modesel) -> u8 {
            Modesel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Nonmainsize(pub u8);
    impl Nonmainsize {
        #[doc = "Minimum value of \\[NONMAINSIZE\\]."]
        pub const MINSECTORS: Self = Self(0x0);
        #[doc = "Maximum value of \\[NONMAINSIZE\\]."]
        pub const MAXSECTORS: Self = Self(0x20);
    }
    impl Nonmainsize {
        pub const fn from_bits(val: u8) -> Nonmainsize {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Nonmainsize {
        #[inline(always)]
        fn from(val: u8) -> Nonmainsize {
            Nonmainsize::from_bits(val)
        }
    }
    impl From<Nonmainsize> for u8 {
        #[inline(always)]
        fn from(val: Nonmainsize) -> u8 {
            Nonmainsize::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Redwidth {
        #[doc = "Redundant data width is 0. Redundancy/Repair not present."]
        W0BIT = 0x0,
        _RESERVED_1 = 0x01,
        #[doc = "Redundant data width is 2 bits."]
        W2BIT = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Redundant data width is 4 bits."]
        W4BIT = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Redwidth {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Redwidth {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Redwidth {
        #[inline(always)]
        fn from(val: u8) -> Redwidth {
            Redwidth::from_bits(val)
        }
    }
    impl From<Redwidth> for u8 {
        #[inline(always)]
        fn from(val: Redwidth) -> u8 {
            Redwidth::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Regionid(pub u8);
    impl Regionid {
        #[doc = "Main Region."]
        pub const MAIN: Self = Self(0x01);
        #[doc = "Non-Main Region."]
        pub const NONMAIN: Self = Self(0x02);
        #[doc = "Trim Region."]
        pub const TRIM: Self = Self(0x04);
        #[doc = "Engr Region."]
        pub const ENGR: Self = Self(0x08);
    }
    impl Regionid {
        pub const fn from_bits(val: u8) -> Regionid {
            Self(val & 0x1f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Regionid {
        #[inline(always)]
        fn from(val: u8) -> Regionid {
            Regionid::from_bits(val)
        }
    }
    impl From<Regionid> for u8 {
        #[inline(always)]
        fn from(val: Regionid) -> u8 {
            Regionid::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Regionsel {
        _RESERVED_0 = 0x0,
        #[doc = "Main Region."]
        MAIN = 0x01,
        #[doc = "Non-Main Region."]
        NONMAIN = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Trim Region."]
        TRIM = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        #[doc = "Engr Region."]
        ENGR = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Regionsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Regionsel {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Regionsel {
        #[inline(always)]
        fn from(val: u8) -> Regionsel {
            Regionsel::from_bits(val)
        }
    }
    impl From<Regionsel> for u8 {
        #[inline(always)]
        fn from(val: Regionsel) -> u8 {
            Regionsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum RisDone {
        #[doc = "Interrupt did not occur."]
        CLR = 0x0,
        #[doc = "Interrupt occurred."]
        SET = 0x01,
    }
    impl RisDone {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RisDone {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RisDone {
        #[inline(always)]
        fn from(val: u8) -> RisDone {
            RisDone::from_bits(val)
        }
    }
    impl From<RisDone> for u8 {
        #[inline(always)]
        fn from(val: RisDone) -> u8 {
            RisDone::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Sectorsize(pub u16);
    impl Sectorsize {
        #[doc = "Sector size is ONEKB."]
        pub const ONEKB: Self = Self(0x0400);
        #[doc = "Sector size is TWOKB."]
        pub const TWOKB: Self = Self(0x0800);
    }
    impl Sectorsize {
        pub const fn from_bits(val: u16) -> Sectorsize {
            Self(val & 0xffff)
        }
        pub const fn to_bits(self) -> u16 {
            self.0
        }
    }
    impl From<u16> for Sectorsize {
        #[inline(always)]
        fn from(val: u16) -> Sectorsize {
            Sectorsize::from_bits(val)
        }
    }
    impl From<Sectorsize> for u16 {
        #[inline(always)]
        fn from(val: Sectorsize) -> u16 {
            Sectorsize::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Size {
        #[doc = "Operate on 1 flash word."]
        ONEWORD = 0x0,
        #[doc = "Operate on 2 flash words."]
        TWOWORD = 0x01,
        #[doc = "Operate on 4 flash words."]
        FOURWORD = 0x02,
        #[doc = "Operate on 8 flash words."]
        EIGHTWORD = 0x03,
        #[doc = "Operate on a flash sector."]
        SECTOR = 0x04,
        #[doc = "Operate on an entire flash bank."]
        BANK = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Size {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Size {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Size {
        #[inline(always)]
        fn from(val: u8) -> Size {
            Size::from_bits(val)
        }
    }
    impl From<Size> for u8 {
        #[inline(always)]
        fn from(val: Size) -> u8 {
            Size::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sserasedis {
        #[doc = "Enable."]
        ENABLE = 0x0,
        #[doc = "Disable."]
        DISABLE = 0x01,
    }
    impl Sserasedis {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sserasedis {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sserasedis {
        #[inline(always)]
        fn from(val: u8) -> Sserasedis {
            Sserasedis::from_bits(val)
        }
    }
    impl From<Sserasedis> for u8 {
        #[inline(always)]
        fn from(val: Sserasedis) -> u8 {
            Sserasedis::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Stat {
        #[doc = "No Interrupt Pending."]
        NO_INTR = 0x0,
        #[doc = "DONE Interrupt Pending."]
        DONE = 0x01,
    }
    impl Stat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stat {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stat {
        #[inline(always)]
        fn from(val: u8) -> Stat {
            Stat::from_bits(val)
        }
    }
    impl From<Stat> for u8 {
        #[inline(always)]
        fn from(val: Stat) -> u8 {
            Stat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Trimsize(pub u8);
    impl Trimsize {
        #[doc = "Minimum value of \\[TRIMSIZE\\]."]
        pub const MINSECTORS: Self = Self(0x0);
        #[doc = "Maximum value of \\[TRIMSIZE\\]."]
        pub const MAXSECTORS: Self = Self(0x20);
    }
    impl Trimsize {
        pub const fn from_bits(val: u8) -> Trimsize {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Trimsize {
        #[inline(always)]
        fn from(val: u8) -> Trimsize {
            Trimsize::from_bits(val)
        }
    }
    impl From<Trimsize> for u8 {
        #[inline(always)]
        fn from(val: Trimsize) -> u8 {
            Trimsize::to_bits(val)
        }
    }
}
